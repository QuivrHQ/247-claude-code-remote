/**
 * Auto-configuration for Claude Code attention hook integration.
 * Creates the attention script and configures Claude settings at agent startup.
 */

import { readFileSync, writeFileSync, existsSync, mkdirSync, chmodSync } from 'fs';
import { homedir } from 'os';
import { join } from 'path';

const CLAUDE_SETTINGS_PATH = join(homedir(), '.claude', 'settings.json');
const HOOK_DIR = join(homedir(), '.247');
const ATTENTION_SCRIPT_PATH = join(HOOK_DIR, 'attention.sh');

// Patterns to detect old hooks that need cleanup
const OLD_HOOK_PATTERNS = [
  /statusline\.sh/,
  /notification\.sh/,
  /stop\.sh/,
  /notify-status\.sh/,
  /packages\/hooks/,
];

/**
 * Ensure attention hook is configured for 247 integration.
 * Called at agent startup.
 */
export function ensureHooksConfigured(): void {
  try {
    ensureAttentionScript();
    ensureClaudeSettings();
    console.log('[Setup] Attention hook configured successfully');
  } catch (err) {
    console.error('[Setup] Failed to configure hooks:', err);
  }
}

/**
 * Create the attention.sh script that forwards Claude Code notifications to the agent.
 * This is called when Claude needs user attention (permission, input, etc.)
 */
function ensureAttentionScript(): void {
  if (!existsSync(HOOK_DIR)) {
    mkdirSync(HOOK_DIR, { recursive: true });
  }

  const script = `#!/bin/bash
# 247 Attention Hook - forwards Claude Code attention events to agent
# Auto-generated by 247 agent - do not edit manually

INPUT=$(cat)
TMUX_SESSION="\${CLAUDE_TMUX_SESSION:-}"

# Only forward if we're in a tmux session managed by 247
[ -z "$TMUX_SESSION" ] && exit 0

# Forward JSON to agent (add tmux_session field)
echo "$INPUT" | jq --arg ts "$TMUX_SESSION" '. + {tmux_session: $ts}' | \\
  curl -s -X POST "http://localhost:4678/api/attention" \\
    -H "Content-Type: application/json" \\
    -d @- > /dev/null 2>&1 &

exit 0
`;

  writeFileSync(ATTENTION_SCRIPT_PATH, script);
  chmodSync(ATTENTION_SCRIPT_PATH, 0o755);
  console.log(`[Setup] Created attention script at ${ATTENTION_SCRIPT_PATH}`);
}

/**
 * Remove old 247 hooks from settings.json.
 */
function cleanupOldHooks(settings: Record<string, unknown>): boolean {
  let cleaned = false;

  // Clean statusLine if it's one of ours
  const statusLine = settings.statusLine as { command?: string } | undefined;
  if (statusLine?.command && OLD_HOOK_PATTERNS.some((p) => p.test(statusLine.command || ''))) {
    delete settings.statusLine;
    console.log('[Setup] Removed old statusLine from settings.json');
    cleaned = true;
  }

  // Clean old hooks
  const hooks = settings.hooks as Record<string, unknown[]> | undefined;
  if (hooks) {
    for (const hookType of ['Notification', 'Stop', 'PreToolUse', 'PostToolUse']) {
      const hookList = hooks[hookType] as
        | Array<{ hooks?: Array<{ command?: string }> }>
        | undefined;
      if (hookList) {
        const filtered = hookList.filter(
          (h) => !h.hooks?.some((hook) => OLD_HOOK_PATTERNS.some((p) => p.test(hook.command || '')))
        );
        if (filtered.length !== hookList.length) {
          if (filtered.length === 0) {
            delete hooks[hookType];
          } else {
            hooks[hookType] = filtered;
          }
          console.log(`[Setup] Cleaned old ${hookType} hooks from settings.json`);
          cleaned = true;
        }
      }
    }

    // Remove hooks object if empty
    if (Object.keys(hooks).length === 0) {
      delete settings.hooks;
    }
  }

  return cleaned;
}

/**
 * Configure Claude settings.json to use our attention hook.
 */
function ensureClaudeSettings(): void {
  const claudeDir = join(homedir(), '.claude');

  // Ensure .claude directory exists
  if (!existsSync(claudeDir)) {
    mkdirSync(claudeDir, { recursive: true });
  }

  // Read existing settings or start fresh
  let settings: Record<string, unknown> = {};
  if (existsSync(CLAUDE_SETTINGS_PATH)) {
    try {
      settings = JSON.parse(readFileSync(CLAUDE_SETTINGS_PATH, 'utf-8'));
    } catch {
      console.warn('[Setup] Could not parse existing settings.json, will create new');
    }
  }

  // Clean up old hooks if present
  const cleaned = cleanupOldHooks(settings);

  const expectedAttentionCommand = `bash ${ATTENTION_SCRIPT_PATH}`;

  // Check if Notification hook is already configured correctly
  const currentHooks = settings.hooks as Record<string, unknown[]> | undefined;
  const notificationHooks = currentHooks?.Notification as
    | Array<{ hooks?: Array<{ command?: string }> }>
    | undefined;
  const attentionConfigured = notificationHooks?.some((h) =>
    h.hooks?.some((hook) => hook.command === expectedAttentionCommand)
  );

  if (attentionConfigured && !cleaned) {
    console.log('[Setup] Attention hook already configured');
    return;
  }

  // Configure hooks
  const hooks = (settings.hooks || {}) as Record<string, unknown[]>;

  // Add our Notification hook (this fires when Claude needs attention)
  if (!attentionConfigured) {
    // Get existing user hooks (preserve them)
    const existingHooks = (hooks.Notification || []) as Array<{
      hooks?: Array<{ command?: string }>;
    }>;

    // Filter out any old 247 hooks
    const userHooks = existingHooks.filter(
      (h) => !h.hooks?.some((hook) => hook.command?.includes('.247/'))
    );

    hooks.Notification = [
      ...userHooks,
      {
        matcher: '*',
        hooks: [
          {
            type: 'command',
            command: expectedAttentionCommand,
          },
        ],
      },
    ];
    console.log('[Setup] Configured Notification hook');
  }

  settings.hooks = hooks;

  writeFileSync(CLAUDE_SETTINGS_PATH, JSON.stringify(settings, null, 2));
  console.log(`[Setup] Configured Claude settings in ${CLAUDE_SETTINGS_PATH}`);
}
